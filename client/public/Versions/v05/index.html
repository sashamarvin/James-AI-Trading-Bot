<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0" />
    <title>Lightweight Chartsâ„¢ Customization</title>
    <script type="text/javascript" src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
      body { padding: 0; margin: 0; }
      .drawing-mode { cursor: url('https://cdn-icons-png.flaticon.com/512/716/716291.png'), auto; }
    </style>
  </head>
  <body>
    <header style="background: #f4f4f4; padding: 10px; text-align: center; font-size: 18px;">
      TradingView Chart UI
    </header>
    <div style="display: flex; height: calc(100vh - 80px);">
      <aside style="width: 250px; background: #f4f4f4; padding: 15px;">
        <h3>Settings</h3>
        <p>Press <strong>âŒ˜ (Command)</strong> on Mac or <strong>Ctrl</strong> on Windows to toggle Draw Mode.</p>
        <p>Press <strong>Delete</strong> or <strong>Backspace</strong> to remove the last trendline.</p>
      </aside>
      <div id="container" style="flex: 1; position: relative;"></div>
    </div>
    <footer style="background: #f4f4f4; padding: 10px; text-align: center;">
      Status: Ready
    </footer>
    
    <script type="text/javascript">
      console.log("DEBUG: Lightweight Charts Version:", LightweightCharts.version);
      
      async function fetchStockData() {
          try {
              const response = await fetch("alphavantage_CART.csv");
              if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
              const data = await response.text();
              const rows = data.split("\n").slice(1);
              return rows.map(row => {
                  const cols = row.split(",");
                  if (cols.length < 5) return null;
                  return { time: cols[0].trim(), open: parseFloat(cols[1]), high: parseFloat(cols[2]), low: parseFloat(cols[3]), close: parseFloat(cols[4]) };
              }).filter(row => row !== null && !isNaN(row.open));
          } catch (error) {
              console.error("ERROR: Failed to load stock data!", error);
              return [];
          }
      } // END: fetchStockData

      const chartContainer = document.getElementById('container');
      const chart = LightweightCharts.createChart(chartContainer);

      chart.applyOptions({
          crosshair: {
              mode: LightweightCharts.CrosshairMode.Normal,
              vertLine: { color: "#808080", width: 1, style: LightweightCharts.LineStyle.Dashed, visible: true },
              horzLine: { color: "#808080", width: 1, style: LightweightCharts.LineStyle.Dashed, visible: true },
          },
      }); // END: Chart Initialization

      let drawMode = false;
      let startPoint = null;
      let trendlines = [];
      let dynamicMarkers = [];
      let mainSeries = null; // Declare globally

      // Toggle Draw Mode (âŒ˜ for Mac, Ctrl for Windows)
      document.addEventListener("keydown", (event) => {
          if (event.metaKey || event.ctrlKey) {
              drawMode = !drawMode;
              document.querySelector("footer").innerText = drawMode ? "âœï¸ Draw Mode: ON" : "Draw Mode: OFF";
              chartContainer.classList.toggle("drawing-mode", drawMode);
              startPoint = null;
          }
      }); // END: Toggle Draw Mode

      document.addEventListener("keydown", (event) => {
            if (event.key === "Delete" || (event.key === "Backspace" && !event.metaKey && !event.ctrlKey)) {
                console.log("ðŸŸ¡ DEBUG: Delete Key Pressed");
                document.querySelector("footer").innerText = "ðŸ—‘ï¸ Delete Key Pressed";

                // ðŸš¨ Check variables before the conditions
                console.log("ðŸŸ¡ DEBUG: Trendlines Length BEFORE delete â†’", trendlines.length);
                console.log("ðŸŸ¡ DEBUG: Markers Length BEFORE delete â†’", dynamicMarkers.length);
                console.log("ðŸŸ¡ DEBUG: Trendlines Array BEFORE delete â†’", trendlines);
                console.log("ðŸŸ¡ DEBUG: Markers Array BEFORE delete â†’", JSON.stringify(dynamicMarkers, null, 2));

                if (trendlines.length > 0) {
                    // ðŸš¨ Trendline exists, so delete it
                    const lastLine = trendlines.pop();
                    console.log("ðŸŸ¢ DEBUG: Removing last trendline:", lastLine);
                    chart.removeSeries(lastLine);

                    // ðŸš¨ Remove last two markers (start & end)
                    if (dynamicMarkers.length >= 2) {
                        dynamicMarkers.pop();
                        dynamicMarkers.pop();
                        console.log("ðŸŸ¢ DEBUG: Removed last two markers.");
                    }
                }

                // ðŸš¨ Extra check: If no trendlines left, delete markers one-by-one
                console.log("ðŸŸ  DEBUG: Checking if markers can still be deleted...");
                console.log("ðŸŸ  DEBUG: Trendlines Length AFTER delete â†’", trendlines.length);
                console.log("ðŸŸ  DEBUG: Markers Length AFTER delete â†’", dynamicMarkers.length);

                if (trendlines.length === 0 && dynamicMarkers.length > 0) {
                    console.log("ðŸŸ  DEBUG: No trendlines left. Removing marker...");
                    dynamicMarkers.pop();
                }

                // ðŸš¨ Final log before updating markers
                console.log("ðŸŸ¡ DEBUG: Markers AFTER delete â†’", dynamicMarkers.length);
                console.log("ðŸŸ¡ DEBUG: Markers Array AFTER delete â†’", JSON.stringify(dynamicMarkers, null, 2));

                // âœ… Refresh markers in the chart
                LightweightCharts.createSeriesMarkers(mainSeries, dynamicMarkers);
                console.log("ðŸŸ¢ DEBUG: Markers updated in chart.");

                // ðŸš¨ Final UI update
                document.querySelector("footer").innerText = 
                    (trendlines.length === 0 && dynamicMarkers.length === 0) 
                    ? "ðŸ—‘ï¸ All Trendlines & Markers Deleted" 
                    : "ðŸ—‘ï¸ Last Item Deleted";
            }
        });

     

      async function loadRealStockData() {
          const stockData = await fetchStockData();
          if (stockData.length === 0) return;
          
          //  const mainSeries = chart.addSeries(LightweightCharts.CandlestickSeries);
          // mainSeries.setData(stockData);

            mainSeries = chart.addSeries(LightweightCharts.CandlestickSeries); // âœ… Assign globally
            mainSeries.setData(stockData);

          

          // âœ… Trendline & Dynamic Marker Logic
          chart.subscribeClick(param => {
              if (!param.time) return;

              const bar = param.seriesData.get(mainSeries);
              if (!bar) return;

              const cursorPrice = mainSeries.coordinateToPrice(param.point.y);
              const snapPrice = findClosestPrice(cursorPrice, bar);

              if (drawMode) {
                  if (!startPoint) {
                      startPoint = { time: param.time, value: snapPrice };
                      console.log("DEBUG: First click stored at", startPoint);

                      // âœ… Place first marker (blue arrowUp)
                      dynamicMarkers.push({
                            time: startPoint.time,
                            position: "belowBar",
                            color: "blue",
                            shape: "arrowUp",
                            text: "",
                        });

                      console.log("DEBUG: typeof LightweightCharts.createSeriesMarkers â†’", typeof LightweightCharts.createSeriesMarkers);
                      // mainSeries.setMarkers(dynamicMarkers);
                      // âœ… Apply static markers correctly
                        //const { createSeriesMarkers } = LightweightCharts;
                        //const seriesMarkers = createSeriesMarkers(mainSeries, dynamicMarkers);
                        LightweightCharts.createSeriesMarkers(mainSeries, dynamicMarkers);

                  } else {
                      const endPoint = { time: param.time, value: snapPrice };

                      if (startPoint.time === endPoint.time && startPoint.value === endPoint.value) {
                          console.warn("âš ï¸ WARN: Identical points selected! Pick a different second point.");
                          return;
                      }

                      console.log("DEBUG: Drawing trendline from", startPoint, "to", endPoint);

                      // âœ… Calculate Percentage Change
                      const percentageChange = ((endPoint.value - startPoint.value) / startPoint.value) * 100;
                      const formattedChange = percentageChange.toFixed(2) + "%";

                      // âœ… Place second marker (red arrowDown with % change)
                      dynamicMarkers.push({
                            time: endPoint.time,
                            position: "aboveBar",
                            color: "red",
                            shape: "arrowDown",
                            text: formattedChange,
                        });

                      // mainSeries.setMarkers(dynamicMarkers);
                      // âœ… Apply static markers correctly
                      const { createSeriesMarkers } = LightweightCharts;
                        const seriesMarkers = createSeriesMarkers(mainSeries, dynamicMarkers);

                      // âœ… Draw Trendline
                      const line = chart.addSeries(LightweightCharts.LineSeries, {
                          color: "blue",
                          lineWidth: 2,
                          lineStyle: LightweightCharts.LineStyle.Solid,
                      });

                      line.setData([startPoint, endPoint]);
                      trendlines.push(line);

                      console.log("âœ… DEBUG: Trendline successfully drawn!");
                      startPoint = null;
                  }
            } else {
                  document.querySelector("footer").innerText =
                      `ðŸ“Œ Clicked on: ${param.time} | O: ${bar.open} H: ${bar.high} L: ${bar.low} C: ${bar.close}`;
              }
          }); // END: chart.subscribeClick
      } // END: loadRealStockData

      loadRealStockData();

      function findClosestPrice(clickPrice, bar) {
          const prices = [bar.open, bar.high, bar.low, bar.close];
          return prices.reduce((closest, curr) =>
              Math.abs(curr - clickPrice) < Math.abs(closest - clickPrice) ? curr : closest
          );
      } // END: findClosestPrice

      window.addEventListener("resize", () => {
          chart.resize(window.innerWidth, window.innerHeight);
      }); // END: window resize
    </script>
  </body>
</html>
